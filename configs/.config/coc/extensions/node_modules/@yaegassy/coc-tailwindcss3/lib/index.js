"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/minimatch/lib/path.js
var require_path = __commonJS({
  "node_modules/minimatch/lib/path.js"(exports, module2) {
    var isWindows = typeof process === "object" && process && process.platform === "win32";
    module2.exports = isWindows ? { sep: "\\" } : { sep: "/" };
  }
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "node_modules/balanced-match/index.js"(exports, module2) {
    "use strict";
    module2.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp)
        a = maybeMatch(a, str);
      if (b instanceof RegExp)
        b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "node_modules/brace-expansion/index.js"(exports, module2) {
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m)
        return [str];
      var pre = m.pre;
      var post = m.post.length ? expand(m.post, false) : [""];
      if (/\$$/.test(m.pre)) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + "{" + m.body + "}" + post[k];
          expansions.push(expansion);
        }
      } else {
        var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
        var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
        var isSequence = isNumericSequence || isAlphaSequence;
        var isOptions = m.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions) {
          if (m.post.match(/,.*\}/)) {
            str = m.pre + "{" + m.body + escClose + m.post;
            return expand(str);
          }
          return [str];
        }
        var n;
        if (isSequence) {
          n = m.body.split(/\.\./);
        } else {
          n = parseCommaParts(m.body);
          if (n.length === 1) {
            n = expand(n[0], false).map(embrace);
            if (n.length === 1) {
              return post.map(function(p) {
                return m.pre + n[0] + p;
              });
            }
          }
        }
        var N;
        if (isSequence) {
          var x = numeric(n[0]);
          var y = numeric(n[1]);
          var width = Math.max(n[0].length, n[1].length);
          var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
          var test = lte;
          var reverse = y < x;
          if (reverse) {
            incr *= -1;
            test = gte;
          }
          var pad = n.some(isPadded);
          N = [];
          for (var i = x; test(i, y); i += incr) {
            var c;
            if (isAlphaSequence) {
              c = String.fromCharCode(i);
              if (c === "\\")
                c = "";
            } else {
              c = String(i);
              if (pad) {
                var need = width - c.length;
                if (need > 0) {
                  var z = new Array(need + 1).join("0");
                  if (i < 0)
                    c = "-" + z + c.slice(1);
                  else
                    c = z + c;
                }
              }
            }
            N.push(c);
          }
        } else {
          N = [];
          for (var j = 0; j < n.length; j++) {
            N.push.apply(N, expand(n[j], false));
          }
        }
        for (var j = 0; j < N.length; j++) {
          for (var k = 0; k < post.length; k++) {
            var expansion = pre + N[j] + post[k];
            if (!isTop || isSequence || expansion)
              expansions.push(expansion);
          }
        }
      }
      return expansions;
    }
  }
});

// node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS({
  "node_modules/minimatch/minimatch.js"(exports, module2) {
    var minimatch2 = module2.exports = (p, pattern, options = {}) => {
      assertValidPattern(pattern);
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      return new Minimatch(pattern, options).match(p);
    };
    module2.exports = minimatch2;
    var path2 = require_path();
    minimatch2.sep = path2.sep;
    var GLOBSTAR = Symbol("globstar **");
    minimatch2.GLOBSTAR = GLOBSTAR;
    var expand = require_brace_expansion();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var charSet = (s) => s.split("").reduce((set, c) => {
      set[c] = true;
      return set;
    }, {});
    var reSpecials = charSet("().*{}+?[]^$\\!");
    var addPatternStartSet = charSet("[.(");
    var slashSplit = /\/+/;
    minimatch2.filter = (pattern, options = {}) => (p, i, list) => minimatch2(p, pattern, options);
    var ext = (a, b = {}) => {
      const t = {};
      Object.keys(a).forEach((k) => t[k] = a[k]);
      Object.keys(b).forEach((k) => t[k] = b[k]);
      return t;
    };
    minimatch2.defaults = (def) => {
      if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return minimatch2;
      }
      const orig = minimatch2;
      const m = (p, pattern, options) => orig(p, pattern, ext(def, options));
      m.Minimatch = class Minimatch extends orig.Minimatch {
        constructor(pattern, options) {
          super(pattern, ext(def, options));
        }
      };
      m.Minimatch.defaults = (options) => orig.defaults(ext(def, options)).Minimatch;
      m.filter = (pattern, options) => orig.filter(pattern, ext(def, options));
      m.defaults = (options) => orig.defaults(ext(def, options));
      m.makeRe = (pattern, options) => orig.makeRe(pattern, ext(def, options));
      m.braceExpand = (pattern, options) => orig.braceExpand(pattern, ext(def, options));
      m.match = (list, pattern, options) => orig.match(list, pattern, ext(def, options));
      return m;
    };
    minimatch2.braceExpand = (pattern, options) => braceExpand(pattern, options);
    var braceExpand = (pattern, options = {}) => {
      assertValidPattern(pattern);
      if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        return [pattern];
      }
      return expand(pattern);
    };
    var MAX_PATTERN_LENGTH = 1024 * 64;
    var assertValidPattern = (pattern) => {
      if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
      }
    };
    var SUBPARSE = Symbol("subparse");
    minimatch2.makeRe = (pattern, options) => new Minimatch(pattern, options || {}).makeRe();
    minimatch2.match = (list, pattern, options = {}) => {
      const mm = new Minimatch(pattern, options);
      list = list.filter((f) => mm.match(f));
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    var globUnescape = (s) => s.replace(/\\(.)/g, "$1");
    var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    var Minimatch = class {
      constructor(pattern, options) {
        assertValidPattern(pattern);
        if (!options)
          options = {};
        this.options = options;
        this.set = [];
        this.pattern = pattern;
        this.regexp = null;
        this.negate = false;
        this.comment = false;
        this.empty = false;
        this.partial = !!options.partial;
        this.make();
      }
      debug() {
      }
      make() {
        const pattern = this.pattern;
        const options = this.options;
        if (!options.nocomment && pattern.charAt(0) === "#") {
          this.comment = true;
          return;
        }
        if (!pattern) {
          this.empty = true;
          return;
        }
        this.parseNegate();
        let set = this.globSet = this.braceExpand();
        if (options.debug)
          this.debug = (...args) => console.error(...args);
        this.debug(this.pattern, set);
        set = this.globParts = set.map((s) => s.split(slashSplit));
        this.debug(this.pattern, set);
        set = set.map((s, si, set2) => s.map(this.parse, this));
        this.debug(this.pattern, set);
        set = set.filter((s) => s.indexOf(false) === -1);
        this.debug(this.pattern, set);
        this.set = set;
      }
      parseNegate() {
        if (this.options.nonegate)
          return;
        const pattern = this.pattern;
        let negate = false;
        let negateOffset = 0;
        for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++) {
          negate = !negate;
          negateOffset++;
        }
        if (negateOffset)
          this.pattern = pattern.substr(negateOffset);
        this.negate = negate;
      }
      matchOne(file, pattern, partial) {
        var options = this.options;
        this.debug(
          "matchOne",
          { "this": this, file, pattern }
        );
        this.debug("matchOne", file.length, pattern.length);
        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
          this.debug("matchOne loop");
          var p = pattern[pi];
          var f = file[fi];
          this.debug(pattern, p, f);
          if (p === false)
            return false;
          if (p === GLOBSTAR) {
            this.debug("GLOBSTAR", [pattern, p, f]);
            var fr = fi;
            var pr = pi + 1;
            if (pr === pl) {
              this.debug("** at the end");
              for (; fi < fl; fi++) {
                if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                  return false;
              }
              return true;
            }
            while (fr < fl) {
              var swallowee = file[fr];
              this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
              if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                this.debug("globstar found match!", fr, fl, swallowee);
                return true;
              } else {
                if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                  this.debug("dot detected!", file, fr, pattern, pr);
                  break;
                }
                this.debug("globstar swallow a segment, and continue");
                fr++;
              }
            }
            if (partial) {
              this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
              if (fr === fl)
                return true;
            }
            return false;
          }
          var hit;
          if (typeof p === "string") {
            hit = f === p;
            this.debug("string match", p, f, hit);
          } else {
            hit = f.match(p);
            this.debug("pattern match", p, f, hit);
          }
          if (!hit)
            return false;
        }
        if (fi === fl && pi === pl) {
          return true;
        } else if (fi === fl) {
          return partial;
        } else if (pi === pl) {
          return fi === fl - 1 && file[fi] === "";
        }
        throw new Error("wtf?");
      }
      braceExpand() {
        return braceExpand(this.pattern, this.options);
      }
      parse(pattern, isSub) {
        assertValidPattern(pattern);
        const options = this.options;
        if (pattern === "**") {
          if (!options.noglobstar)
            return GLOBSTAR;
          else
            pattern = "*";
        }
        if (pattern === "")
          return "";
        let re = "";
        let hasMagic = !!options.nocase;
        let escaping = false;
        const patternListStack = [];
        const negativeLists = [];
        let stateChar;
        let inClass = false;
        let reClassStart = -1;
        let classStart = -1;
        let cs;
        let pl;
        let sp;
        const patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
        const clearStateChar = () => {
          if (stateChar) {
            switch (stateChar) {
              case "*":
                re += star;
                hasMagic = true;
                break;
              case "?":
                re += qmark;
                hasMagic = true;
                break;
              default:
                re += "\\" + stateChar;
                break;
            }
            this.debug("clearStateChar %j %j", stateChar, re);
            stateChar = false;
          }
        };
        for (let i = 0, c; i < pattern.length && (c = pattern.charAt(i)); i++) {
          this.debug("%s	%s %s %j", pattern, i, re, c);
          if (escaping) {
            if (c === "/") {
              return false;
            }
            if (reSpecials[c]) {
              re += "\\";
            }
            re += c;
            escaping = false;
            continue;
          }
          switch (c) {
            case "/": {
              return false;
            }
            case "\\":
              clearStateChar();
              escaping = true;
              continue;
            case "?":
            case "*":
            case "+":
            case "@":
            case "!":
              this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
              if (inClass) {
                this.debug("  in class");
                if (c === "!" && i === classStart + 1)
                  c = "^";
                re += c;
                continue;
              }
              this.debug("call clearStateChar %j", stateChar);
              clearStateChar();
              stateChar = c;
              if (options.noext)
                clearStateChar();
              continue;
            case "(":
              if (inClass) {
                re += "(";
                continue;
              }
              if (!stateChar) {
                re += "\\(";
                continue;
              }
              patternListStack.push({
                type: stateChar,
                start: i - 1,
                reStart: re.length,
                open: plTypes[stateChar].open,
                close: plTypes[stateChar].close
              });
              re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
              this.debug("plType %j %j", stateChar, re);
              stateChar = false;
              continue;
            case ")":
              if (inClass || !patternListStack.length) {
                re += "\\)";
                continue;
              }
              clearStateChar();
              hasMagic = true;
              pl = patternListStack.pop();
              re += pl.close;
              if (pl.type === "!") {
                negativeLists.push(pl);
              }
              pl.reEnd = re.length;
              continue;
            case "|":
              if (inClass || !patternListStack.length) {
                re += "\\|";
                continue;
              }
              clearStateChar();
              re += "|";
              continue;
            case "[":
              clearStateChar();
              if (inClass) {
                re += "\\" + c;
                continue;
              }
              inClass = true;
              classStart = i;
              reClassStart = re.length;
              re += c;
              continue;
            case "]":
              if (i === classStart + 1 || !inClass) {
                re += "\\" + c;
                continue;
              }
              cs = pattern.substring(classStart + 1, i);
              try {
                RegExp("[" + cs + "]");
              } catch (er) {
                sp = this.parse(cs, SUBPARSE);
                re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
                hasMagic = hasMagic || sp[1];
                inClass = false;
                continue;
              }
              hasMagic = true;
              inClass = false;
              re += c;
              continue;
            default:
              clearStateChar();
              if (reSpecials[c] && !(c === "^" && inClass)) {
                re += "\\";
              }
              re += c;
              break;
          }
        }
        if (inClass) {
          cs = pattern.substr(classStart + 1);
          sp = this.parse(cs, SUBPARSE);
          re = re.substr(0, reClassStart) + "\\[" + sp[0];
          hasMagic = hasMagic || sp[1];
        }
        for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
          let tail;
          tail = re.slice(pl.reStart + pl.open.length);
          this.debug("setting tail", re, pl);
          tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, (_, $1, $2) => {
            if (!$2) {
              $2 = "\\";
            }
            return $1 + $1 + $2 + "|";
          });
          this.debug("tail=%j\n   %s", tail, tail, pl, re);
          const t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
          hasMagic = true;
          re = re.slice(0, pl.reStart) + t + "\\(" + tail;
        }
        clearStateChar();
        if (escaping) {
          re += "\\\\";
        }
        const addPatternStart = addPatternStartSet[re.charAt(0)];
        for (let n = negativeLists.length - 1; n > -1; n--) {
          const nl = negativeLists[n];
          const nlBefore = re.slice(0, nl.reStart);
          const nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
          let nlAfter = re.slice(nl.reEnd);
          const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter;
          const openParensBefore = nlBefore.split("(").length - 1;
          let cleanAfter = nlAfter;
          for (let i = 0; i < openParensBefore; i++) {
            cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
          }
          nlAfter = cleanAfter;
          const dollar = nlAfter === "" && isSub !== SUBPARSE ? "$" : "";
          re = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        }
        if (re !== "" && hasMagic) {
          re = "(?=.)" + re;
        }
        if (addPatternStart) {
          re = patternStart + re;
        }
        if (isSub === SUBPARSE) {
          return [re, hasMagic];
        }
        if (!hasMagic) {
          return globUnescape(pattern);
        }
        const flags = options.nocase ? "i" : "";
        try {
          return Object.assign(new RegExp("^" + re + "$", flags), {
            _glob: pattern,
            _src: re
          });
        } catch (er) {
          return new RegExp("$.");
        }
      }
      makeRe() {
        if (this.regexp || this.regexp === false)
          return this.regexp;
        const set = this.set;
        if (!set.length) {
          this.regexp = false;
          return this.regexp;
        }
        const options = this.options;
        const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
        const flags = options.nocase ? "i" : "";
        let re = set.map((pattern) => {
          pattern = pattern.map(
            (p) => typeof p === "string" ? regExpEscape(p) : p === GLOBSTAR ? GLOBSTAR : p._src
          ).reduce((set2, p) => {
            if (!(set2[set2.length - 1] === GLOBSTAR && p === GLOBSTAR)) {
              set2.push(p);
            }
            return set2;
          }, []);
          pattern.forEach((p, i) => {
            if (p !== GLOBSTAR || pattern[i - 1] === GLOBSTAR) {
              return;
            }
            if (i === 0) {
              if (pattern.length > 1) {
                pattern[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + pattern[i + 1];
              } else {
                pattern[i] = twoStar;
              }
            } else if (i === pattern.length - 1) {
              pattern[i - 1] += "(?:\\/|" + twoStar + ")?";
            } else {
              pattern[i - 1] += "(?:\\/|\\/" + twoStar + "\\/)" + pattern[i + 1];
              pattern[i + 1] = GLOBSTAR;
            }
          });
          return pattern.filter((p) => p !== GLOBSTAR).join("/");
        }).join("|");
        re = "^(?:" + re + ")$";
        if (this.negate)
          re = "^(?!" + re + ").*$";
        try {
          this.regexp = new RegExp(re, flags);
        } catch (ex) {
          this.regexp = false;
        }
        return this.regexp;
      }
      match(f, partial = this.partial) {
        this.debug("match", f, this.pattern);
        if (this.comment)
          return false;
        if (this.empty)
          return f === "";
        if (f === "/" && partial)
          return true;
        const options = this.options;
        if (path2.sep !== "/") {
          f = f.split(path2.sep).join("/");
        }
        f = f.split(slashSplit);
        this.debug(this.pattern, "split", f);
        const set = this.set;
        this.debug(this.pattern, "set", set);
        let filename;
        for (let i = f.length - 1; i >= 0; i--) {
          filename = f[i];
          if (filename)
            break;
        }
        for (let i = 0; i < set.length; i++) {
          const pattern = set[i];
          let file = f;
          if (options.matchBase && pattern.length === 1) {
            file = [filename];
          }
          const hit = this.matchOne(file, pattern, partial);
          if (hit) {
            if (options.flipNegate)
              return true;
            return !this.negate;
          }
        }
        if (options.flipNegate)
          return false;
        return this.negate;
      }
      static defaults(def) {
        return minimatch2.defaults(def).Minimatch;
      }
    };
    minimatch2.Minimatch = Minimatch;
  }
});

// node_modules/normalize-path/index.js
var require_normalize_path = __commonJS({
  "node_modules/normalize-path/index.js"(exports, module2) {
    module2.exports = function(path2, stripTrailing) {
      if (typeof path2 !== "string") {
        throw new TypeError("expected path to be a string");
      }
      if (path2 === "\\" || path2 === "/")
        return "/";
      var len = path2.length;
      if (len <= 1)
        return path2;
      var prefix = "";
      if (len > 4 && path2[3] === "\\") {
        var ch = path2[2];
        if ((ch === "?" || ch === ".") && path2.slice(0, 2) === "\\\\") {
          path2 = path2.slice(2);
          prefix = "//";
        }
      }
      var segs = path2.split(/[/\\]+/);
      if (stripTrailing !== false && segs[segs.length - 1] === "") {
        segs.pop();
      }
      return prefix + segs.join("/");
    };
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  activate: () => activate2,
  deactivate: () => deactivate
});
module.exports = __toCommonJS(src_exports);
var import_coc3 = require("coc.nvim");
var import_fs = __toESM(require("fs"));
var import_path = __toESM(require("path"));
var import_minimatch = __toESM(require_minimatch());
var import_normalize_path = __toESM(require_normalize_path());

// src/config.ts
var import_coc = require("coc.nvim");
function getConfigTailwindCssEnable() {
  return import_coc.workspace.getConfiguration("tailwindCSS").get("enable");
}
function getConfigCustomServerPath() {
  return import_coc.workspace.getConfiguration("tailwindCSS").get("custom.serverPath", "");
}
function getConfigExcludePatterns() {
  return import_coc.workspace.getConfiguration("tailwindCSS").get("files.exclude", []);
}

// src/constants.ts
var CONFIG_GLOB = "{tailwind,tailwind.config,tailwind.*.config,tailwind.config.*}.{js,cjs,ts,mjs}";

// src/util/array.ts
function dedupe(arr) {
  return arr.filter((value, index, self) => self.indexOf(value) === index);
}
function equal(a, b) {
  if (a === b)
    return true;
  if (a.length !== b.length)
    return false;
  const aSorted = a.concat().sort();
  const bSorted = b.concat().sort();
  for (let i = 0; i < aSorted.length; ++i) {
    if (aSorted[i] !== bSorted[i])
      return false;
  }
  return true;
}

// src/util/isObject.ts
function isObject(variable) {
  return Object.prototype.toString.call(variable) === "[object Object]";
}

// src/util/languages.ts
var htmlLanguages = [
  "aspnetcorerazor",
  "astro",
  "astro-markdown",
  "blade",
  "django-html",
  "edge",
  "ejs",
  "erb",
  "gohtml",
  "GoHTML",
  "haml",
  "handlebars",
  "hbs",
  "html",
  "HTML (Eex)",
  "HTML (EEx)",
  "html-eex",
  "htmldjango",
  "jade",
  "leaf",
  "liquid",
  "markdown",
  "mdx",
  "mustache",
  "njk",
  "nunjucks",
  "phoenix-heex",
  "php",
  "razor",
  "slim",
  "twig"
];
var cssLanguages = ["css", "less", "postcss", "sass", "scss", "stylus", "sugarss"];
var jsLanguages = ["javascript", "javascriptreact", "reason", "rescript", "typescript", "typescriptreact"];
var specialLanguages = ["vue", "svelte"];
var languages = [...cssLanguages, ...htmlLanguages, ...jsLanguages, ...specialLanguages];

// src/headwind/headwindFeature.ts
var import_coc2 = require("coc.nvim");

// src/headwind/headwindUtils.ts
var sortClassString = (classString, sortOrder2, options) => {
  let classArray = classString.split(options.separator || /\s+/g);
  if (options.shouldRemoveDuplicates) {
    classArray = removeDuplicates(classArray);
  }
  const sortOrderClone = [...sortOrder2];
  if (options.customTailwindPrefix.length > 0) {
    for (let i = 0; i < sortOrderClone.length; i++) {
      sortOrderClone[i] = options.customTailwindPrefix + sortOrderClone[i];
    }
  }
  classArray = sortClassArray(classArray, sortOrderClone, options.shouldPrependCustomClasses);
  return classArray.join(options.replacement || " ").trim();
};
var sortClassArray = (classArray, sortOrder2, shouldPrependCustomClasses2) => [
  ...classArray.filter((el) => shouldPrependCustomClasses2 && sortOrder2.indexOf(el) === -1),
  ...classArray.filter((el) => sortOrder2.indexOf(el) !== -1).sort((a, b) => sortOrder2.indexOf(a) - sortOrder2.indexOf(b)),
  ...classArray.filter((el) => !shouldPrependCustomClasses2 && sortOrder2.indexOf(el) === -1)
];
var removeDuplicates = (classArray) => [...new Set(classArray)];
function isArrayOfStrings(value) {
  return Array.isArray(value) && value.every((item) => typeof item === "string");
}
function buildMatcher(value) {
  if (typeof value === "string") {
    return {
      regex: [new RegExp(value, "gi")]
    };
  } else if (isArrayOfStrings(value)) {
    return {
      regex: value.map((v) => new RegExp(v, "gi"))
    };
  } else if (value == void 0) {
    return {
      regex: []
    };
  } else {
    return {
      regex: typeof value.regex === "string" ? [new RegExp(value.regex, "gi")] : isArrayOfStrings(value.regex) ? value.regex.map((v) => new RegExp(v, "gi")) : [],
      separator: typeof value.separator === "string" ? new RegExp(value.separator, "g") : void 0,
      replacement: value.replacement || value.separator
    };
  }
}
function buildMatchers(value) {
  if (value == void 0) {
    return [];
  } else if (Array.isArray(value)) {
    if (!value.length) {
      return [];
    } else if (!isArrayOfStrings(value)) {
      return value.map((v) => buildMatcher(v));
    }
  }
  return [buildMatcher(value)];
}
function getTextMatch(regexes, text, callback, startPosition = 0) {
  if (regexes.length >= 1) {
    let wrapper;
    while ((wrapper = regexes[0].exec(text)) !== null) {
      const wrapperMatch = wrapper[0];
      const valueMatchIndex = wrapper.findIndex((match, idx) => idx !== 0 && match);
      const valueMatch = wrapper[valueMatchIndex];
      const newStartPosition = startPosition + wrapper.index + wrapperMatch.lastIndexOf(valueMatch);
      if (regexes.length === 1) {
        callback(valueMatch, newStartPosition);
      } else {
        getTextMatch(regexes.slice(1), valueMatch, callback, newStartPosition);
      }
    }
  }
}

// src/headwind/headwindFeature.ts
var config = import_coc2.workspace.getConfiguration();
var langConfig = config.get("tailwindCSS.headwind.classRegex") || {};
var sortOrder = config.get("tailwindCSS.headwind.defaultSortOrder");
var customTailwindPrefixConfig = config.get("tailwindCSS.headwind.customTailwindPrefix");
var customTailwindPrefix = typeof customTailwindPrefixConfig === "string" ? customTailwindPrefixConfig : "";
var shouldRemoveDuplicatesConfig = config.get("tailwindCSS.headwind.removeDuplicates");
var shouldRemoveDuplicates = typeof shouldRemoveDuplicatesConfig === "boolean" ? shouldRemoveDuplicatesConfig : true;
var shouldPrependCustomClassesConfig = config.get("tailwindCSS.headwind.prependCustomClasses");
var shouldPrependCustomClasses = typeof shouldPrependCustomClassesConfig === "boolean" ? shouldPrependCustomClassesConfig : false;
var isActive = false;
function activate(context, outputChannel) {
  if (isActive) {
    return;
  }
  isActive = true;
  context.subscriptions.push({
    dispose() {
      isActive = false;
    }
  });
  const disposable = import_coc2.commands.registerCommand("tailwindCSS.headwind.sortTailwindClasses", async () => {
    const doc = await import_coc2.workspace.document;
    const editorText = doc.textDocument.getText();
    const editorLangId = doc.textDocument.languageId;
    outputChannel.appendLine(`
${"#".repeat(10)} headwind exec
`);
    outputChannel.appendLine(`editorLangId: ${editorLangId}`);
    outputChannel.appendLine(`langConfig: ${JSON.stringify(langConfig[editorLangId], null, 2)}
`);
    const matchers = buildMatchers(langConfig[editorLangId] || langConfig["html"]);
    for (const matcher of matchers) {
      getTextMatch(matcher.regex, editorText, (text, startPosition) => {
        outputChannel.appendLine(`Regex: ${matcher.regex}`);
        outputChannel.appendLine(`MatchText: ${text}
`);
        const endPosition = startPosition + text.length;
        const range = import_coc2.Range.create(
          doc.textDocument.positionAt(startPosition),
          doc.textDocument.positionAt(endPosition)
        );
        const options = {
          shouldRemoveDuplicates,
          shouldPrependCustomClasses,
          customTailwindPrefix,
          separator: matcher.separator,
          replacement: matcher.replacement
        };
        doc.applyEdits([
          {
            range,
            newText: sortClassString(text, Array.isArray(sortOrder) ? sortOrder : [], options)
          }
        ]);
      });
    }
  });
  context.subscriptions.push(disposable);
  if (config.get("tailwindCSS.headwind.runOnSave")) {
    context.subscriptions.push(
      import_coc2.workspace.onWillSaveTextDocument((_e) => {
        import_coc2.commands.executeCommand("tailwindCSS.headwind.sortTailwindClasses");
      })
    );
  }
}

// src/index.ts
var clients = /* @__PURE__ */ new Map();
var languages2 = /* @__PURE__ */ new Map();
var _sortedWorkspaceFolders;
function sortedWorkspaceFolders() {
  if (_sortedWorkspaceFolders === void 0) {
    _sortedWorkspaceFolders = import_coc3.workspace.workspaceFolders ? import_coc3.workspace.workspaceFolders.map((folder) => {
      let result = folder.uri.toString();
      if (result.charAt(result.length - 1) !== "/") {
        result = result + "/";
      }
      return result;
    }).sort((a, b) => {
      return a.length - b.length;
    }) : [];
  }
  return _sortedWorkspaceFolders;
}
function getOuterMostWorkspaceFolder(folder) {
  const sorted = sortedWorkspaceFolders();
  for (const element of sorted) {
    let uri = folder.uri.toString();
    if (uri.charAt(uri.length - 1) !== "/") {
      uri = uri + "/";
    }
    if (uri.startsWith(element)) {
      const workdir = import_coc3.workspace.getWorkspaceFolder(element);
      if (workdir) {
        return workdir;
      }
    }
  }
  return folder;
}
function getUserLanguages(folder) {
  const langs = folder ? import_coc3.workspace.getConfiguration("tailwindCSS", folder.uri.toString()).includeLanguages : void 0;
  return isObject(langs) ? langs : {};
}
function isExcluded(file, folder) {
  const exclude = getConfigExcludePatterns();
  for (const pattern of exclude) {
    if ((0, import_minimatch.default)(file, import_path.default.join(import_coc3.Uri.parse(folder.uri).fsPath, pattern))) {
      return true;
    }
  }
  return false;
}
async function activate2(context) {
  if (!getConfigTailwindCssEnable())
    return;
  let module2 = getConfigCustomServerPath();
  if (module2 && import_fs.default.existsSync(module2)) {
    module2 = module2;
  } else {
    module2 = context.asAbsolutePath(
      import_path.default.join("node_modules", "@tailwindcss", "language-server", "bin", "tailwindcss-language-server")
    );
  }
  const outputChannel = import_coc3.window.createOutputChannel("tailwindcss-language-server");
  context.subscriptions.push(
    import_coc3.commands.registerCommand("tailwindCSS.showOutput", () => {
      if (outputChannel) {
        outputChannel.show();
      }
    })
  );
  const configWatcher = import_coc3.workspace.createFileSystemWatcher(`**/${CONFIG_GLOB}`, false, true, true);
  configWatcher.onDidCreate((uri) => {
    let folder = import_coc3.workspace.getWorkspaceFolder(uri.toString());
    if (!folder || isExcluded(uri.fsPath, folder)) {
      return;
    }
    folder = getOuterMostWorkspaceFolder(folder);
    bootWorkspaceClient(folder);
  });
  context.subscriptions.push(configWatcher);
  context.subscriptions.push(
    import_coc3.workspace.onDidChangeConfiguration((event) => {
      clients.forEach((client, key) => {
        const folder = import_coc3.workspace.getWorkspaceFolder(import_coc3.Uri.parse(key).toString());
        if (!folder)
          return;
        if (event.affectsConfiguration("tailwindCSS.includeLanguages", folder.uri.toString())) {
          const userLanguages = getUserLanguages(folder);
          if (userLanguages) {
            const userLanguageIds = Object.keys(userLanguages);
            const newLanguages = dedupe([...languages, ...userLanguageIds]);
            if (!equal(newLanguages, languages2.get(folder.uri.toString()))) {
              languages2.set(folder.uri.toString(), newLanguages);
              if (client) {
                clients.delete(folder.uri.toString());
                client.stop();
                bootWorkspaceClient(folder);
              }
            }
          }
        }
      });
    })
  );
  function bootWorkspaceClient(folder) {
    if (clients.has(folder.uri.toString())) {
      return;
    }
    clients.set(folder.uri.toString(), null);
    if (!languages2.has(folder.uri.toString())) {
      languages2.set(folder.uri.toString(), dedupe([...languages, ...Object.keys(getUserLanguages(folder))]));
    }
    const configuration = {
      edidor: import_coc3.workspace.getConfiguration("editor"),
      tailwindCSS: import_coc3.workspace.getConfiguration("tailwindCSS")
    };
    const inspectPort = configuration.tailwindCSS.get("inspectPort", null);
    activate(context, outputChannel);
    const serverOptions = {
      run: {
        module: module2,
        transport: import_coc3.TransportKind.ipc,
        options: { execArgv: inspectPort === null ? [] : [`--inspect=${inspectPort}`] }
      },
      debug: {
        module: module2,
        transport: import_coc3.TransportKind.ipc,
        options: {
          execArgv: ["--nolazy", `--inspect=${6011 + clients.size}`]
        }
      }
    };
    const languageObj = languages2.get(folder.uri.toString());
    if (!languageObj)
      return;
    const documentSelector = languageObj.map((language) => ({
      scheme: "file",
      language,
      pattern: (0, import_normalize_path.default)(`${import_coc3.Uri.parse(folder.uri).fsPath.replace(/[\[\]\{\}]/g, "?")}/**/*`)
    }));
    const clientOptions = {
      documentSelector,
      diagnosticCollectionName: "tailwindcss-language-server",
      workspaceFolder: folder,
      outputChannel,
      synchronize: {
        fileEvents: import_coc3.workspace.createFileSystemWatcher(CONFIG_GLOB)
      },
      middleware: {
        workspace: {
          configuration: (params) => {
            return params.items.map(({ section, scopeUri }) => {
              let scope = folder;
              if (scopeUri) {
                const doc = import_coc3.workspace.textDocuments.find((doc2) => doc2.uri.toString() === scopeUri);
                if (doc) {
                  scope = {
                    languageId: doc.languageId
                  };
                }
              }
              return import_coc3.workspace.getConfiguration(section);
            });
          }
        }
      },
      initializationOptions: {
        userLanguages: getUserLanguages(folder)
      }
    };
    const client = new import_coc3.LanguageClient("tailwindCSS", "Tailwind CSS Language Server", serverOptions, clientOptions);
    client.onRequest("@/tailwindCSS/getDocumentSymbols", async ({ uri }) => {
    });
    client.start();
    clients.set(folder.uri.toString(), client);
  }
  async function didOpenTextDocument(document) {
    const uri = import_coc3.Uri.parse(document.uri);
    if (uri.scheme !== "file")
      return;
    const supportedLanguages = [];
    supportedLanguages.push(...languages);
    const includeLanguages = import_coc3.workspace.getConfiguration("tailwindCSS").get("includeLanguages");
    if (includeLanguages)
      supportedLanguages.push(...Object.keys(includeLanguages));
    if (!supportedLanguages.includes(document.languageId))
      return;
    let folder = import_coc3.workspace.getWorkspaceFolder(document.uri);
    if (!folder) {
      return;
    }
    folder = getOuterMostWorkspaceFolder(folder);
    bootWorkspaceClient(folder);
  }
  context.subscriptions.push(import_coc3.workspace.onDidOpenTextDocument(didOpenTextDocument));
  import_coc3.workspace.textDocuments.forEach(didOpenTextDocument);
  context.subscriptions.push(
    import_coc3.workspace.onDidChangeWorkspaceFolders((event) => {
      _sortedWorkspaceFolders = void 0;
      for (const folder of event.removed) {
        const client = clients.get(folder.uri.toString());
        if (client) {
          clients.delete(folder.uri.toString());
          client.stop();
        }
      }
    })
  );
}
async function deactivate() {
  const promises = [];
  for (const client of clients.values()) {
    if (client) {
      promises.push(client.stop());
    }
  }
  return Promise.all(promises).then(() => void 0);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  activate,
  deactivate
});
/*!
 * normalize-path <https://github.com/jonschlinkert/normalize-path>
 *
 * Copyright (c) 2014-2018, Jon Schlinkert.
 * Released under the MIT License.
 */
